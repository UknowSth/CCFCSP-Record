# 题解记录

由于对于C++语言没有进行过系统的学习，在解题过程中主要是体会从C过渡到C++的过程

## 寻宝冒险

首先，在处理输入数据时，直接将原题中的左下角变为左上角，相当于将整个图像上下反转，显然结论依然是成立，处理条件是不变的。

而关键在于对于地图上的每一棵树，也就是存储下来的每一个坐标，都要以它为起点来检查一个宫格内的树的情况是否与藏宝图的情况对应。那么这就是一个查找问题，主要的任务是给定一个点对`(i.j)`，要检查它是否在集合中。由于输入并没有说明其顺序，首先先考虑最普通的线性搜索方法看会不会超时。

## 角色授权

这是一个模拟的问题，题目的背景比较复杂，但是对于算法方面基本没有要求。

问题中有多个类型的对象，包括用户、用户组、角色、角色关联。显然输入的前n,m行是用来构建整个关系网络的，而q行是用来查询的，因为用户所属的用户组在不用情况下可能会有差异，q行彼此之间的关系是独立的。

由于在q行中，每一行对应的是一个操作，以此为一个单位，需要进行的判断是：

* 查找用户`user`与哪个角色`role`关联
* 查找角色`role`的权限是否包括对某资源做某操作
* 重复以上过程，用户判断完以后依次判断其所属的用户组

从以上过程中可以发现需要构建的函数功能包括：

* 给定一个用户/用户组，找到它关联的角色
* 给定一个角色和对资源的操作，确认这个角色能否对资源进行对应的操作

除了函数功能以外，需要考虑构建的对象包括：

* **角色**

  * 角色名称（Key）
  * 角色的操作集合
  * 角色操作集合的大小
  * 角色资源类型集合
  * 角色资源类型集合大小
  * 角色资源名称集合
  * 角色资源名称集合大小
  * 角色关联的对象数量
  * 角色关联的对象信息

    * u/g
    * 名称

  鉴于这些大小都无法提前确定，建议在读入数以后再执行分配的操作

考虑到本任务对字符串的要求可能比较高，用C风格的字符串可能不太合适，使用C++的`string`类型

```cpp
string * s;
s = new string [6]; // 可以用这种方式来创建字符数组
```

此外注意到，给出的m行数据中角色名称可能存在重复

写代码的过程中发现这种重复可能会导致需要使用到`realloc`的功能，因此在C++中这种分配数组的实现方式可能会比较麻烦，尽管可以使用自己封装的函数来实现一个`realloc`但还是会带来一些多余的繁琐操作。使用`vector`可能是一个更好的选择。

~~在处理角色关联信息时，需要在vector中进行查找，为了方便代码编写，了解了find_if函数。~~~~由于find_if只能选用一元函数作为规则，不适合查找指定的字符串，遂弃。~~

使用了[Vector常用的遍历方法](https://blog.csdn.net/hw140701/article/details/78833486)来实现查找功能

然而尝试以后发现结果是错误的，尝试找了相关解答并再一次重新开始设计思路。尽管有些狼狈...但考虑到对C++不太熟悉，这种尝试也促使我去将C++的stl实际用在解决问题上吧，并不是没有收获。尝试的过程中发现，C++毕竟是有封装好的数据类型的，不像C一样需要从头开始考虑这么多，不会受到数组的一些细节问题的影响，思路上可能并不像用C解决问题一样考虑得太细，stl的工具可以帮助我们简化问题，所以慢慢地向C++过渡是非常有必要的。

---

下面是看了其他解答以后重新开始的复现过程记录。

首先熟悉了一下`map`这一容器，参考[知乎相关文章](https://zhuanlan.zhihu.com/p/127860466 "C++中map的用法总结")。它的定位类似于`python`中的字典。而`unordered_map`则类似于是无序的`map`，可以了解一下[unorderde_map介绍](http://c.biancheng.net/view/7231.html)。

在参考思路中，主要使用了`map`容器来解决问题。看代码过程中注意到的用法：

* 在`map<xxx,int>`中，用`M.count("key")==0`来判断对应的`key`是否存在于这个`map`中
* 可以使用`map<xxx,int>`来保存一个将值映射到`index`的结构，这样不用每一次都线性地查找，尤其对于在不重复数组中查找的情况，可以通过这样的处理来“空间换时间”

在本题中似乎测试样例里并不存在用户组名与用户名重名的情况，因此处理时直接把这两个处理为地位相等的对象了，如果考虑重名，只需要分别开两个`map`，并不困难。

此外在参考代码的思路中，构建了反映“用户拥有哪些角色”的`map`，在原思路中，一个用户需要在输入时临时去找它所拥有的角色。从这里发现，事实上原来的思路（即完全按照题目的意思按图索骥地搜索）中有很多浪费时间的操作。这都是在设计时没有考虑到的。CSP还是需要一些减少时间复杂度的操作的，即使这并不设计具体的算法。所以即使是模拟题也要想清楚了再开始写。

根据这种思路重新顺一遍整个题的查询过程，其中将相较于原思路中改善的部分标注了出来：

* 输入角色拥有的操作权限等信息，对每个角色都设置三个`map`来反映是否有权限，这样**可以不用线性搜索**。

  事实上这种处理就相当于是构建了集合(set)，只是额外把该值是否在其中设置为了`value`（取1/0）而已
* 角色本身要存在一个可迭代的结构中，要能够迅速搜索到它，于是把它的下标存储在了`map`中，这样在查找角色时**可以不用线性搜索**

  如果只看目的似乎更适合`map`的结构...<u>也许可以尝试一下</u>
* 用户/用户组拥有的哪些角色，设置一个`map<string,vector<string>>`

  **省去了大量时间**

在第二次尝试以后，发现无论是时间还是空间，都和参考的代码有较大的差异，尤其是空间可能由于出现了`bug`导致使用的空间大小远超题目的限制。因此对代码进行比对反思原因。

---

以下记录比对代码过程中发现的处理上的不同：

* 对于所有角色结构体构成的数组，参考代码直接以数组形式定义了，而本人代码采用了`vector`

  在将`vector`更改为数组以后，占用空间的大小和采用的时间都得到了大幅度的下降
* 参考代码采用了`ios::sync_with_stdio(false);`语句来取消`scanf`与`cin`的同步，加快了`cin`的速度

  不过这种处理使得代码中不能使用`scanf`了

  在使用该语句以后，占用空间依然较大
* 对于一些循环，参考代码使用了下标迭代，而本人的代码使用的是迭代器

  个人认为区别不是很大.......

可以看出对于`R`这个可迭代的结构，使用数组比使用`vector`的效率要高很多，这是本题卡住的关键。为什么呢...

---

查阅资料[Vector内存分配与释放](https://zhuanlan.zhihu.com/p/338390842)以后发现`vector`使用不恰当很容易导致内存泄露的情况.

总的来说对于`vector`的定义，尽量避免使用`push_back`操作是正确的，其结果也可以从本题的解决方案中看出来，面对比较大型的数据，不断的`push_back`可能会不断地触发扩张内存。使用`resize`来指定大小，然后像数组一样用下标访问即可。

> 总之能用resize()就用，能不用push_back()就不用，一旦用了，根据情况，需要清空的一定要正确及时的清空，避免内存损耗和溢出！
>

> vector的内存空间是只增加不减少的，我们常用的操作clear()和erase()，实际上只是减少了size()，清除了数据，并不会减少capacity，所以内存空间没有减少。**那么如何释放内存空间呢，正确的做法是swap()操作。**
>

当 swap() 成员方法用于清空 vector 容器时，可以套用如下的语法格式：

```cpp
vector<T>().swap(x);

vector<int> ().swap(vec); // 释放整个vecter空间：
vector<int> (vec).swap(vec); // 释放vec中多余空间
```

这里没有为 vector<T>() 表达式传递任何参数。这意味着，此表达式将调用 vector 模板类的默认构造函数，而不再是复制构造函数。也就是说，此格式会先生成一个空的 vector 容器，再借助 swap() 方法将空容器交换给 x，从而达到**清空 x** 的目的。

将原来的使用`vector`的代码中插入部分更改为首先`resize(n)`再用下标访问的方法，也可以获得满分。可见即使是动态内存，`vector`也只是封装了C中类似于`realloc`的方法，能够预先指定大小尽量预先指定大小。
